diff --git a/dist/src/types/YMap.d.ts b/dist/src/types/YMap.d.ts
index 00b8e8178827727172ed32930e6c76c1b1842f64..afc16e705fce70d7daedcee42b7e87e97230efcb 100644
--- a/dist/src/types/YMap.d.ts
+++ b/dist/src/types/YMap.d.ts
@@ -19,7 +19,7 @@ export class YMapEvent<T> extends YEvent<YMap<T>> {
  * @extends AbstractType<YMapEvent<MapType>>
  * @implements {Iterable<MapType>}
  */
-export class YMap<MapType> extends AbstractType<YMapEvent<MapType>> implements Iterable<MapType> {
+export class YMap<Data extends Record<string, unknown> = Record<string, unknown>> extends AbstractType<YMapEvent<Data>> implements Iterable<Data> {
     /**
      *
      * @param {Iterable<readonly [string, any]>=} entries - an optional iterable to initialize the YMap
@@ -45,7 +45,7 @@ export class YMap<MapType> extends AbstractType<YMapEvent<MapType>> implements I
     /**
      * @return {YMap<MapType>}
      */
-    clone(): YMap<MapType>;
+    clone(): YMap<Data>;
     /**
      * Transforms this Shared Type to a JSON object.
      *
@@ -83,7 +83,7 @@ export class YMap<MapType> extends AbstractType<YMapEvent<MapType>> implements I
      *
      * @param {function(MapType,string,YMap<MapType>):void} f A function to execute on every element of this YArray.
      */
-    forEach(f: (arg0: MapType, arg1: string, arg2: YMap<MapType>) => void): void;
+    forEach(f: (arg0: Data, arg1: string, arg2: YMap<Data>) => void): void;
     /**
      * Remove a specified element from this YMap.
      *
@@ -96,21 +96,21 @@ export class YMap<MapType> extends AbstractType<YMapEvent<MapType>> implements I
      * @param {string} key The key of the element to add to this YMap
      * @param {MapType} value The value of the element to add
      */
-    set(key: string, value: MapType): MapType;
+    set<Key extends keyof Data & string>(key: Key, value: Data[Key]): Data[Key];
     /**
      * Returns a specified element from this YMap.
      *
      * @param {string} key
      * @return {MapType|undefined}
      */
-    get(key: string): MapType | undefined;
+    get<Key extends keyof Data & string>(key: Key): Data[Key];
     /**
      * Returns a boolean indicating whether the specified key exists or not.
      *
      * @param {string} key The key to test.
      * @return {boolean}
      */
-    has(key: string): boolean;
+    has<Key extends keyof Data & string>(key: Key): boolean;
     /**
      * Removes all elements from this YMap.
      */
diff --git a/dist/src/utils/Doc.d.ts b/dist/src/utils/Doc.d.ts
index fd83b70c2db35b93609102c7832e9d30c77c9267..51a5cea1ba9914c57f4df065901c5917e877610e 100644
--- a/dist/src/utils/Doc.d.ts
+++ b/dist/src/utils/Doc.d.ts
@@ -13,7 +13,7 @@ export const generateNewClientId: typeof random.uint32;
  * A Yjs instance handles the state of shared data.
  * @extends Observable<string>
  */
-export class Doc extends Observable<string> {
+export class Doc<Data extends Record<string, AbstractType<any>> = Record<string, AbstractType<any>>> extends Observable<string> {
     /**
      * @param {DocOpts} [opts] configuration
      */
@@ -72,33 +72,6 @@ export class Doc extends Observable<string> {
      * @public
      */
     public transact(f: (arg0: Transaction) => void, origin?: any): void;
-    /**
-     * Define a shared data type.
-     *
-     * Multiple calls of `y.get(name, TypeConstructor)` yield the same result
-     * and do not overwrite each other. I.e.
-     * `y.define(name, Y.Array) === y.define(name, Y.Array)`
-     *
-     * After this method is called, the type is also available on `y.share.get(name)`.
-     *
-     * *Best Practices:*
-     * Define all types right after the Yjs instance is created and store them in a separate object.
-     * Also use the typed methods `getText(name)`, `getArray(name)`, ..
-     *
-     * @example
-     *   const y = new Y(..)
-     *   const appState = {
-     *     document: y.getText('document')
-     *     comments: y.getArray('comments')
-     *   }
-     *
-     * @param {string} name
-     * @param {Function} TypeConstructor The constructor of the type definition. E.g. Y.Text, Y.Array, Y.Map, ...
-     * @return {AbstractType<any>} The created type. Constructed with TypeConstructor
-     *
-     * @public
-     */
-    public get(name: string, TypeConstructor?: Function): AbstractType<any>;
     /**
      * @template T
      * @param {string} [name]
@@ -106,14 +79,14 @@ export class Doc extends Observable<string> {
      *
      * @public
      */
-    public getArray<T>(name?: string | undefined): YArray<T>;
+    public getArray<Key extends keyof Data & string>(name: Key): Data[Key] extends YArray<any> ? Data[Key] : never;
     /**
      * @param {string} [name]
      * @return {YText}
      *
      * @public
      */
-    public getText(name?: string | undefined): YText;
+    public getText<Key extends keyof Data & string>(name: Key): Data[Key] extends YText ? Data[Key] : never;
     /**
      * @template T
      * @param {string} [name]
@@ -121,25 +94,7 @@ export class Doc extends Observable<string> {
      *
      * @public
      */
-    public getMap<T_1>(name?: string | undefined): YMap<T_1>;
-    /**
-     * @param {string} [name]
-     * @return {YXmlFragment}
-     *
-     * @public
-     */
-    public getXmlFragment(name?: string | undefined): YXmlFragment;
-    /**
-     * Converts the entire document into a js object, recursively traversing each yjs type
-     * Doesn't log types that have not been defined (using ydoc.getType(..)).
-     *
-     * @deprecated Do not use this method and rather call toJSON directly on the shared types.
-     *
-     * @return {Object<string, any>}
-     */
-    toJSON(): {
-        [x: string]: any;
-    };
+    public getMap<Key extends keyof Data & string>(name: Key): Data[Key] extends YMap<any> ? Data[Key] : never;
     /**
      * @param {string} eventName
      * @param {function(...any):any} f